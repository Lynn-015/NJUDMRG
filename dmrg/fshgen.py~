'''
one-dimensional hamiltonian generator for dmrg
'''
import numpy as np
from scipy.sparse import kron,identity,lil_matrix
from scipy.sparse.linalg import eigsh
from copy import copy,deepcopy

from ops import Onsite,OnsiteS,TwoSite,TwoSiteS,TwoSiteF,TwoSiteFS

class HGen(object):
	'''
	father class of LHGen and RHGen
	
	attributes:
	l:length of chain
	d:dimension of single site hilbert space
	D:dimension of total hibert space
	H:hamiltonian matrix
	pterms:terms need to be handled
	terms:hamiltonian terms
	'''
	def __init__(self,terms,d,sectors=np.array([1.,0.,0.,-1.])):
		self.l=1
		self.d=d
		self.D=self.d
		self.H=np.zeros([self.d,self.d])
		self.terms=terms
		self.pterms=[]
		self.single_site_sectors=sectors
		self.basis_sector_array=copy(self.single_site_sectors)
		self.basis_by_sector=index_map(self.basis_sector_array)

class LHGen(HGen):
	'''
	left hamiltonian generator
	construct:LHGen(terms,d)

	attributes:
	same as HGen
	'''
	def __init__(self,terms,d):
		HGen.__init__(self,terms,d)
		for term in self.terms:
			if isinstance(term,(Onsite,OnsiteS)): #onsite term
				self.H=self.H+term.op.mat*term.param
			elif isinstance(term,(TwoSite,TwoSiteS)) and (term.op1.site is None or term.op1.site==1):
				pterm=deepcopy(term)
				pterm.op1.site=1
				pterm.op2.site=1+pterm.dist
				self.pterms.append(pterm)

	def enlarge(self):
		'''enlarge one site towards right'''
		self.l=self.l+1
		self.H=kron(self.H,identity(self.d))
		pts=[]
		for pterm in self.pterms:
			if pterm.op2.site==self.l:
				self.H=self.H+kron(pterm.op1.mat,pterm.op2.mat)*pterm.param
			else:
				pterm.op1.mat=kron(pterm.op1.mat,identity(self.d)) #should kron z
				pts.append(pterm)
		self.pterms=deepcopy(pts)
		for term in self.terms:
			if isinstance(term,(Onsite,OnsiteS)) and (term.op.site is None or term.op.site==self.l):
				self.H=self.H+kron(identity(D),term.op1.mat)*term.param
			elif isinstance(term,(TwoSite,TwoSiteS)) and (term.op1.site is None or term.op1.site==self.l):
				pterm=deepcopy(term)
				pterm.op1.mat=kron(identity(self.D),pterm.op1.mat)
				pterm.op1.site=self.l
				pterm.op2.site=self.l+pterm.dist
				self.pterms.append(pterm)
		self.D=self.D*self.d

		self.basis_sector_array=np.add.outer(self.basis_sector_array,self.single_site_sectors).flatten()
		self.basis_by_sector=index_map(self.basis_sector_array)

	def truncate(self,U):
		'''truncate H and part_terms with U'''
		self.H=U.conjugate().transpose().dot(self.H.dot(U))
		for pterm in self.pterms:
			pterm.op1.mat=U.conjugate().transpose().dot(pterm.op1.mat.dot(U))
		self.D=self.H.shape[0] 

class RHGen(HGen):
	'''
	right hamiltonian generator
	construct:RHGen(terms,d,N)

	attributes:
	N:length of whole chain
	same as HGen 
	'''
	def __init__(self,terms,d,N): #mirror image not used
		HGen.__init__(self,terms,d)
		self.N=N
		for term in self.terms:
			if isinstance(term,(Onsite,OnsiteS)) and (term.op.site is None or term.op.site==N):
				self.H=self.H+term.op.mat*term.param
			elif isinstance(term,(TwoSite,TwoSiteS)) and (term.op2.site is None or term.op2.site==N):
				pterm=deepcopy(term)
				pterm.op2.site=N
				pterm.op1.site=N-pterm.dist
				self.pterms.append(pterm)

	def enlarge(self):
		self.l=self.l+1
		self.H=kron(identity(self.d),self.H)
		pts=[]
		for pterm in self.pterms:
			if pterm.op1.site==self.N-self.l+1:
				self.H=self.H+kron(pterm.op1.mat,pterm.op2.mat)*pterm.param
			else:
				pterm.op2.mat=kron(identity(self.d),pterm.op2.mat)
				pts.append(pterm)
		self.pterms=deepcopy(pts)
		for term in self.terms:
			if isinstance(term,(Onsite,OnsiteS)) and (term.op.site is None or term.op.site==self.N-self.l+1):
				self.H=self.H+kron(term.op.mat,identity(self.D))*term.param
			elif isinstance(term,(TwoSite,TwoSiteS)) and (term.op2.site is None or term.op2.site==self.N-self.l+1):
				pterm=deepcopy(term)
				pterm.op2.mat=kron(pterm.op2.mat,identity(self.D))
				pterm.op2.site=self.N-self.l+1
				pterm.op1.site=self.N-self.l+1-pterm.dist
				self.pterms.append(pterm)
		self.D=self.D*self.d

		self.basis_sector_array=np.add.outer(self.single_site_sectors,self.basis_sector_array).flatten()
		self.basis_by_sector=index_map(self.basis_sector_array)

	def truncate(self,V):
		self.H=V.conjugate().transpose().dot(self.H.dot(V))
		for pterm in self.pterms:
			pterm.op2.mat=V.conjugate().transpose().dot(pterm.op2.mat.dot(V))
		self.D=self.H.shape[0]
	'''
	def rtruncate(self,V):
		self.H=V.dot(self.H.dot(V.conjugate().transpose()))
		for pterm in self.pterms:
			pterm.op2.mat=V.dot(pterm.op2.mat.dot(V.conjugate().transpose()))
		self.D=self.H.shape[0]
	'''
class SuperBlock(object):
	'''
	super block hamiltonian generator

	attributes:
	lhgen:left hamiltonian generator
	rhgen:right hamiltonian generator
	H:super block hamiltonian matrix
	'''
	def __init__(self,lhgen,rhgen,target_sz=0.,joint=True):
		self.lhgen=deepcopy(lhgen)
		self.rhgen=deepcopy(rhgen)
		self.L=self.lhgen.l+self.rhgen.l
		self.H=kron(self.lhgen.H,identity(self.rhgen.D))+kron(identity(self.lhgen.D),self.rhgen.H)
		if joint==True:
			for lpterm in self.lhgen.pterms:
				for rpterm in self.rhgen.pterms:
					if (lpterm.op1.label,lpterm.op2.label)==(rpterm.op1.label,rpterm.op2.label) and (lpterm.op1.site+self.rhgen.N-self.L,lpterm.op2.site+self.rhgen.N-self.L)==(rpterm.op1.site,rpterm.op2.site): 
						self.H=self.H+kron(lpterm.op1.mat,rpterm.op2.mat)*lpterm.param

		self.target_sz=target_sz
		self.sector_indices={}
		self.rsector_indices={} #
		self.restricted_basis_indices=[]
		for sys_sz,sys_basis_states in self.lhgen.basis_by_sector.items():
			self.sector_indices[sys_sz]=[]
			env_sz=target_sz-sys_sz
			if env_sz in self.rhgen.basis_by_sector:
				self.rsector_indices[env_sz]=[] #
				for i in sys_basis_states:
					i_offset=self.rhgen.D*i
					for j in self.rhgen.basis_by_sector[env_sz]:
						current_index=len(self.restricted_basis_indices)
						self.sector_indices[sys_sz].append(current_index)
						self.rsector_indices[env_sz].append(current_index) #
						self.restricted_basis_indices.append(i_offset+j)
		self.restricted_superblock_hamiltonian=self.H.todense()[:,self.restricted_basis_indices][self.restricted_basis_indices,:] 
		#todense() and back may cause slow?
		#use sparse may cause some difference?

	def eigen(self,psi0_guess=None):
		#(energy,),self.restricted_psi0=eigsh(self.restricted_superblock_hamiltonian,k=1,which="SA")
		#return energy,self.restricted_psi0
		if psi0_guess is not None:
			restricted_psi0_guess = psi0_guess[self.restricted_basis_indices]			
		else:
			restricted_psi0_guess = None	
		energys,restricted_psi0s=eigsh(self.restricted_superblock_hamiltonian,k=1,which="SA",v0=restricted_psi0_guess)
		self.restricted_psi0=restricted_psi0s[:,0]

		self.full_psi0=np.zeros([self.lhgen.D*self.rhgen.D,1],dtype='d')
		for i,z in enumerate(self.restricted_basis_indices):
			self.full_psi0[z,0]=self.restricted_psi0[i]

		if psi0_guess is not None:
			overlap = np.absolute(np.dot(psi0_guess.conjugate().transpose(), self.full_psi0).item())
			overlap /= np.linalg.norm(psi0_guess) * np.linalg.norm(self.full_psi0)  # normalize it
			print "overlap =", overlap

		return energys[0],self.restricted_psi0

		#es,self.psis=eigsh(self.H,k=1,which="SA")
		#self.psi0=self.psis[:,0]
		#return es[0],self.psis[:,0]

	def ntransform(self,m): #normal transformation
		psi=self.psi0.reshape([self.lhgen.D,self.rhgen.D])
		rhoA=psi.dot(psi.conjugate().transpose())
		vals,vecs=eigsh(rhoA,m,which='SA')
		U=vecs
		rhoB=psi.transpose().dot(psi.conjugate())
		vals2,vecs2=eigsh(rhoB,m,which='SA')
		V=vecs2
		return U,V

	def transform(self,m):
		rho_block_dict={}
		for sys_sz,indices in self.sector_indices.items():
			if indices:
				psi0_sector=self.restricted_psi0[indices]
				psi0_sector=psi0_sector.reshape([len(self.lhgen.basis_by_sector[sys_sz]),-1],order="C")
				rho_block_dict[sys_sz]=np.dot(psi0_sector,psi0_sector.conjugate().transpose())
				
		possible_eigenstates=[]
		for sz_sector,rho_block in rho_block_dict.items():
			evals,evecs=np.linalg.eigh(rho_block)
			current_sector_basis=self.lhgen.basis_by_sector[sz_sector]
			for eval,evec in zip(evals,evecs.transpose()):
				possible_eigenstates.append((eval,evec,sz_sector,current_sector_basis))
		possible_eigenstates.sort(reverse=True,key=lambda x:x[0])
	
		my_m=min(len(possible_eigenstates),m)
		transformation_matrix=lil_matrix((self.lhgen.D,my_m),dtype='d')
		self.new_sector_array=np.zeros((my_m,),dtype='d')

		for i,(eval,evec,sz_sector,current_sector_basis) in enumerate(possible_eigenstates[:my_m]):
			for j,v in zip(current_sector_basis,evec):
				transformation_matrix[j,i]=v
			self.new_sector_array[i]=sz_sector
		self.new_basis_by_sector=index_map(self.new_sector_array)

		transformation_matrix=transformation_matrix.tocsr()
		return transformation_matrix

	def rtransform(self,m): #maybe no need
		rho_block_dict={}
		for env_sz,indices in self.rsector_indices.items():
			if indices: #
				psi0_sector=self.restricted_psi0[indices]
				psi0_sector=psi0_sector.reshape([-1,len(self.rhgen.basis_by_sector[env_sz])],order="C")
				rho_block_dict[env_sz]=np.dot(psi0_sector.transpose(),psi0_sector.conjugate())

		possible_eigenstates=[]
		for sz_sector,rho_block in rho_block_dict.items():
			evals,evecs=np.linalg.eigh(rho_block)
			current_sector_basis=self.rhgen.basis_by_sector[sz_sector]
			for eval,evec in zip(evals,evecs.transpose()):
				possible_eigenstates.append((eval,evec,sz_sector,current_sector_basis))
		possible_eigenstates.sort(reverse=True,key=lambda x:x[0])

		my_m=min(len(possible_eigenstates),m)
		transformation_matrix=lil_matrix((self.rhgen.D,my_m),dtype='d') #
		self.rnew_sector_array=np.zeros((my_m,),dtype='d')
		
		for i,(eval,evec,sz_sector,current_sector_basis) in enumerate(possible_eigenstates[:my_m]):
			for j,v in zip(current_sector_basis,evec):
				transformation_matrix[j,i]=v #
			self.rnew_sector_array[i]=sz_sector
		self.rnew_basis_by_sector=index_map(self.rnew_sector_array)
		
		transformation_matrix=transformation_matrix.tocsr()
		return transformation_matrix

def index_map(array):
    d = {}
    for index, value in enumerate(array):
        d.setdefault(value, []).append(index)
    return d
			
